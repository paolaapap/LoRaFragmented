#ifndef LORAFRAGMENTEDAPP_H
#define LORAFRAGMENTEDAPP_H

#include <omnetpp.h>
#include <string>
#include <vector>
#include <functional>
#include <numeric>
#include <algorithm>

#include "FragEncoder.h"
#include "FragDecoder.h"

#define FRAGMENTATION_DATA_FRAGMENT_CMD 0x08
#define FRAGMENTATION_PORT 201

namespace fragmentedApp {
    std::vector<std::vector<uint8_t>> generateCodedFragments(
                const std::vector<uint8_t>& originalFileBuffer,
                uint16_t numFragments,
                uint8_t fragmentSize,
                uint16_t numCodedFragmentsToGenerate
            );

    void FragDecoderInit( uint16_t fragNb, uint8_t fragSize, FragDecoderCallbacks_t *callbacks );
    int32_t FragDecoderProcess( uint16_t fragCounter, uint8_t *rawData );
    FragDecoderStatus_t FragDecoderGetStatus( void );

    #define FRAG_SESSION_ONGOING            -1
    #define FRAG_SESSION_FINISHED_OK         0
    #define FRAG_SESSION_FINISHED_ERROR      1
}

enum FragSessionStatus {
    FRAG_SESSION_NOT_STARTED = -2,
    FRAG_SESSION_ONGOING_APP = -1,
    FRAG_SESSION_FINISHED_OK_APP = 0,
    FRAG_SESSION_FINISHED_ERROR_APP = 1
};

struct FragDecoderAppStatus {
    uint16_t FragNbRx;
    uint16_t FragNbLost;
    bool MatrixError;
};

struct FragSessionParameters {
    uint16_t fragNb;
    uint8_t fragSize;
    uint8_t m;
    uint8_t redundancy;
    uint8_t padding;
    uint8_t fragIndex;
};

using FragDecoderWriteCallback = std::function<void(uint32_t addr, const void* buffer, uint32_t size)>;
using FragDecoderReadCallback = std::function<void(uint32_t addr, void* buffer, uint32_t size)>;
using FragDecoderEraseCallback = std::function<void(void)>;

class LoRaFragmentedApp
{
  protected:
    FragSessionParameters sessionParams;

    std::vector<uint8_t> rxFragmentBuffer;

    FragSessionStatus txSessionStatus;
    FragSessionStatus rxSessionStatus;

    uint32_t packetsSent;
    uint32_t packetsReceived;
    uint32_t packetsPassedToDecoder;
    uint32_t successfulDecodings;
    uint32_t failedDecodings;

    std::function<void(const std::vector<uint8_t>&, uint8_t, uint8_t)> sendLoRaPacketCallback;
    std::function<void(const std::vector<uint8_t>&, uint8_t, uint8_t)> sendLoRaControlPacketCallback;


  public:
    LoRaFragmentedApp();
    ~LoRaFragmentedApp();

    void initialize(const FragSessionParameters& params,
                    FragDecoderWriteCallback writeCb,
                    FragDecoderReadCallback readCb,
                    FragDecoderEraseCallback eraseCb);

    void finish();

    void startTransmission(const std::vector<uint8_t>& originalData);

    void onLoRaPacketReceived(const std::vector<uint8_t>& packetData, uint8_t port, uint8_t rssi, uint8_t snr);

    void setSendLoRaPacketCallback(std::function<void(const std::vector<uint8_t>&, uint8_t, uint8_t)> callback) {
        sendLoRaPacketCallback = callback;
    }

    void setSendLoRaControlPacketCallback(std::function<void(const std::vector<uint8_t>&, uint8_t, uint8_t)> callback) {
        sendLoRaControlPacketCallback = callback;
    }

    FragDecoderAppStatus getDecoderStatus() const;
    FragSessionStatus getTxSessionStatus() const { return txSessionStatus; }
    FragSessionStatus getRxSessionStatus() const { return rxSessionStatus; }
    uint32_t getPacketsSent() const { return packetsSent; }
    uint32_t getPacketsReceived() const { return packetsReceived; }
    uint32_t getPacketsPassedToDecoder() const { return packetsPassedToDecoder; }
    uint32_t getSuccessfulDecodings() const { return successfulDecodings; }
    uint32_t getFailedDecodings() const { return failedDecodings; }

    void resetRxSession();
};

#endif // LORAFRAGMENTEDAPP_H

#include "LoRaFragmentedApp.h"
#include <iostream>
#include <numeric>
#include <algorithm>

#include "FragEncoder.h"
#include "FragDecoder.h"

using namespace fragmentedApp;

LoRaFragmentedApp::LoRaFragmentedApp() :
    txSessionStatus(FRAG_SESSION_NOT_STARTED),
    rxSessionStatus(FRAG_SESSION_NOT_STARTED),
    packetsSent(0),
    packetsReceived(0),
    packetsPassedToDecoder(0),
    successfulDecodings(0),
    failedDecodings(0)
{
}

LoRaFragmentedApp::~LoRaFragmentedApp()
{
}

void LoRaFragmentedApp::initialize(const FragSessionParameters& params,
                                   FragDecoderWriteCallback writeCb,
                                   FragDecoderReadCallback readCb,
                                   FragDecoderEraseCallback eraseCb)
{
    this->sessionParams = params;

    FragDecoderCallbacks_t decoderCallbacks = {writeCb, readCb, eraseCb};
    fragmentedApp::FragDecoderInit(sessionParams.fragNb, sessionParams.fragSize, &decoderCallbacks);

    rxFragmentBuffer.resize(sessionParams.fragSize);

    EV << "LoRaFragmentedApp initialized with M=" << (int)sessionParams.m
       << ", R=" << (int)sessionParams.redundancy
       << ", FragSize=" << (int)sessionParams.fragSize
       << ", Total Fragments=" << (int)sessionParams.fragNb
       << ", Session Index=" << (int)sessionParams.fragIndex << "\n";
}

void LoRaFragmentedApp::finish() {
    EV << "LoRaFragmentedApp finished. Sent: " << packetsSent
       << ", Received: " << packetsReceived
       << ", Passed to Decoder: " << packetsPassedToDecoder
       << ", Successful Decodings: " << successfulDecodings
       << ", Failed Decodings: " << failedDecodings << "\n";
}

void LoRaFragmentedApp::startTransmission(const std::vector<uint8_t>& originalData)
{
    if (!sendLoRaPacketCallback) {
        EV_ERROR << "LoRaFragmentedApp: Send callback not set. Cannot start transmission.\n";
        txSessionStatus = FRAG_SESSION_FINISHED_ERROR_APP;
        return;
    }

    txSessionStatus = FRAG_SESSION_ONGOING_APP;
    packetsSent = 0;

    std::vector<uint8_t> paddedOriginalData = originalData;
    size_t expectedEncoderInputSize = static_cast<size_t>(sessionParams.m) * sessionParams.fragSize;
    if (paddedOriginalData.size() < expectedEncoderInputSize) {
        paddedOriginalData.resize(expectedEncoderInputSize, 0);
    } else if (paddedOriginalData.size() > expectedEncoderInputSize) {
        EV_ERROR << "Original data size (" << originalData.size() << ") exceeds M * FragSize (" << expectedEncoderInputSize << "). Truncating.\n";
        paddedOriginalData.resize(expectedEncoderInputSize);
    }

    std::vector<std::vector<uint8_t>> allCodedFragments =
        fragmentedApp::generateCodedFragments(paddedOriginalData,
                                               sessionParams.m,
                                               sessionParams.fragSize,
                                               sessionParams.fragNb);

    if (allCodedFragments.empty() || allCodedFragments.size() != sessionParams.fragNb) {
        EV_ERROR << "Failed to generate coded fragments or incorrect number of fragments generated.\n";
        txSessionStatus = FRAG_SESSION_FINISHED_ERROR_APP;
        return;
    }

    for (uint16_t i = 0; i < sessionParams.fragNb; ++i) {
        uint16_t fragCounter = i;

        uint16_t headerValue = (static_cast<uint16_t>(sessionParams.fragIndex & 0x03) << 14) | (fragCounter & 0x3FFF);

        const std::vector<uint8_t>& currentFragment = allCodedFragments[i];

        std::vector<uint8_t> packetToSend;
        packetToSend.push_back(FRAGMENTATION_DATA_FRAGMENT_CMD);
        packetToSend.push_back((headerValue >> 8) & 0xFF);
        packetToSend.push_back(headerValue & 0xFF);
        packetToSend.insert(packetToSend.end(), currentFragment.begin(), currentFragment.end());

        sendLoRaPacketCallback(packetToSend, FRAGMENTATION_PORT, 0);
        packetsSent++;
        EV << "Sent fragment " << i << " (Session Index: " << (int)sessionParams.fragIndex
           << ", Header Value: 0x" << std::hex << headerValue << std::dec << ")\n";
    }
    txSessionStatus = FRAG_SESSION_FINISHED_OK_APP;
}

void LoRaFragmentedApp::onLoRaPacketReceived(const std::vector<uint8_t>& packetData, uint8_t port, uint8_t rssi, uint8_t snr)
{
    packetsReceived++;

    if (port != FRAGMENTATION_PORT) {
        EV << "Received packet on wrong port: " << (int)port << ". Expected " << (int)FRAGMENTATION_PORT << ". Ignoring.\n";
        return;
    }
    if (packetData.size() < 3) {
        EV << "Received too small packet (" << packetData.size() << " bytes). Ignoring.\n";
        return;
    }

    uint8_t command = packetData[0];
    if (command != FRAGMENTATION_DATA_FRAGMENT_CMD) {
        EV << "Received control command (0x" << std::hex << (int)command << "). Ignoring for now.\n";
        return;
    }

    uint16_t headerValue = (static_cast<uint16_t>(packetData[1]) << 8) | packetData[2];
    uint8_t receivedFragIndex = (headerValue >> 14) & 0x03;
    uint16_t receivedFragCounter = headerValue & 0x3FFF;

    if (receivedFragIndex != sessionParams.fragIndex) {
        EV << "Received fragment for wrong session index (" << (int)receivedFragIndex << "). Expected " << (int)sessionParams.fragIndex << ". Ignoring.\n";
        return;
    }

    size_t payloadSize = packetData.size() - 3;
    if (payloadSize != sessionParams.fragSize) {
        EV << "Received fragment with wrong payload size (" << payloadSize << " bytes). Expected " << (int)sessionParams.fragSize << ". Ignoring.\n";
        return;
    }
    std::copy(packetData.begin() + 3, packetData.end(), rxFragmentBuffer.begin());

    EV << "Received fragment " << receivedFragCounter << " (Session Index: " << (int)receivedFragIndex << "). Passing to decoder.\n";
    packetsPassedToDecoder++;

    if (rxSessionStatus == FRAG_SESSION_NOT_STARTED) {
        rxSessionStatus = FRAG_SESSION_ONGOING_APP;
    }

    int32_t decodeStatus = fragmentedApp::FragDecoderProcess(receivedFragCounter, rxFragmentBuffer.data());

    if (decodeStatus == FRAG_SESSION_FINISHED_OK) {
        rxSessionStatus = FRAG_SESSION_FINISHED_OK_APP;
        successfulDecodings++;
        EV << "Decoding successful! Original data reconstructed.\n";
    } else if (decodeStatus == FRAG_SESSION_FINISHED_ERROR) {
        rxSessionStatus = FRAG_SESSION_FINISHED_ERROR_APP;
        failedDecodings++;
        EV_ERROR << "Decoding failed! Matrix error or too many lost fragments.\n";
    }
}

FragDecoderAppStatus LoRaFragmentedApp::getDecoderStatus() const {
    fragmentedApp::FragDecoderStatus_t internalStatus = fragmentedApp::FragDecoderGetStatus();
    FragDecoderAppStatus appStatus;
    appStatus.FragNbRx = internalStatus.FragNbRx;
    appStatus.FragNbLost = internalStatus.FragNbLost;
    appStatus.MatrixError = (internalStatus.MatrixError == 1);
    return appStatus;
}

void LoRaFragmentedApp::resetRxSession() {
    rxSessionStatus = FRAG_SESSION_NOT_STARTED;
    packetsPassedToDecoder = 0;
}


#ifndef MYLORAAPP_H
#define MYLORAAPP_H

#include <omnetpp.h>
#include <vector>
#include <string>
#include <memory> // Per std::unique_ptr
#include <functional> // Per std::bind e std::placeholders

#include "LoRaFragmentedApp.h" // Include la tua app logica di frammentazione
#include "inet/applications/contract/IApp.h"
#include "inet/common/lifecycle/NodeStatus.h" // Per NodeStatus
#include "flora/LoRa/LoRaWANPacket_m.h" // Header per i messaggi LoRaWAN di FLoRa

namespace flora {

class MyLoRaApp : public inet::IApp
{
  protected:
    // Parametri configurabili da omnetpp.ini
    int numOriginalFragments;   // M
    int numRedundantFragments;  // R
    int fragmentSize;           // Dimensione di ciascun frammento in byte
    int dataSize;               // Dimensione totale dei dati da frammentare
    double transmissionInterval; // Intervallo tra gli invii (se non trasmetto tutto subito)

    // Modulo applicativo core per la frammentazione
    std::unique_ptr<LoRaFragmentedApp> fragmentedApp;

    // Buffer per la memoria simulata del decoder
    std::vector<uint8_t> decoderMemory;
    uint32_t decoderMemorySize; // Dimensione totale della memoria allocata per il decoder

    // Eventi timer per OMNeT++
    omnetpp::cMessage *startAppTimer;

    // Segnali per le statistiche (da registrare in omnetpp.ini)
    omnetpp::simsignal_t decodingSuccessSignal;
    omnetpp::simsignal_t fragmentsReceivedSignal;
    omnetpp::simsignal_t fragmentsLostSignal;
    omnetpp::simsignal_t packetsSentSignal;
    omnetpp::simsignal_t matrixErrorSignal;
    omnetpp::simsignal_t overheadRatioSignal; // Overhead: (Pacchetti_Ricevuti_Validi / M)


  protected:
    virtual void initialize(int stage) override;
    virtual void handleMessage(omnetpp::cMessage *msg) override;
    virtual void refreshDisplay() const override;
    virtual void finish() override;

    // Metodi callback per LoRaFragmentedApp (saranno passati come std::function)
    void sendLoRaPacket(const std::vector<uint8_t>& packetData, uint8_t port, uint8_t confirmType);

    // Funzioni di accesso alla memoria per FragDecoder
    void fragDecoderWrite(uint32_t addr, const void* buffer, uint32_t size);
    void fragDecoderRead(uint32_t addr, void* buffer, uint32_t size);
    void fragDecoderErase();

    // Metodo per avviare la trasmissione
    void startDataTransmission();

    // Funzione per generare dati casuali
    std::vector<uint8_t> generateRandomData(size_t size);
};

} // namespace flora

#endif // MYLORAAPP_H


#include "MyLoRaApp.h"
#include "inet/common/ModuleAccess.h"
#include "inet/common/Time.h"
#include "inet/networklayer/common/L3AddressResolver.h"
#include "inet/common/packet/Packet.h" // Per inet::Packet
#include "inet/common/ModuleAccess.h" // Per findModuleByPath
#include "flora/LoRa/LoRaWANPacket_m.h" // Assicurati sia incluso
#include "inet/common/Time.h" // Per simTime()

namespace flora {

Define_Module(MyLoRaApp);

void MyLoRaApp::initialize(int stage)
{
    // Chiamata all'inizializzazione del modulo base (IApp)
    inet::IApp::initialize(stage);

    if (stage == INITSTAGE_LOCAL) {
        // Parametri dal file omnetpp.ini
        numOriginalFragments = par("numOriginalFragments");
        numRedundantFragments = par("numRedundantFragments");
        fragmentSize = par("fragmentSize");
        dataSize = par("dataSize");
        transmissionInterval = par("transmissionInterval").doubleValue();

        // Calcola il numero totale di frammenti
        int totalFragments = numOriginalFragments + numRedundantFragments;
        if (totalFragments > 16383) { // 2^14 - 1 (massimo per 14 bit di fragCounter)
             throw omnetpp::cRuntimeError("Total number of fragments exceeds 14-bit limit (16383).");
        }

        // La dimensione della memoria del decoder deve essere sufficiente per tutti i frammenti
        decoderMemorySize = totalFragments * fragmentSize;
        decoderMemory.resize(decoderMemorySize);

        // Inizializza LoRaFragmentedApp
        fragmentedApp = std::make_unique<LoRaFragmentedApp>();

        // Crea la struttura FragSessionParameters e popolala
        FragSessionParameters sessionParams;
        sessionParams.m = numOriginalFragments;
        sessionParams.redundancy = numRedundantFragments;
        sessionParams.fragNb = totalFragments;
        sessionParams.fragSize = fragmentSize;
        // Calcola il padding: (M * FragSize) - DataSize
        // Se DataSize > (M * FragSize), significa che i dati non entrano, lancia un errore
        if (dataSize > (numOriginalFragments * fragmentSize)) {
            throw omnetpp::cRuntimeError("Data size exceeds the capacity of original fragments (M * FragSize).");
        }
        sessionParams.padding = (numOriginalFragments * fragmentSize) - dataSize;
        // L'indice di sessione è 0 per una singola sessione nel tuo caso
        sessionParams.fragIndex = 0;

        // Inizializza LoRaFragmentedApp con la struttura dei parametri e le callback
        fragmentedApp->initialize(sessionParams,
                                  std::bind(&MyLoRaApp::fragDecoderWrite, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3),
                                  std::bind(&MyLoRaApp::fragDecoderRead, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3),
                                  std::bind(&MyLoRaApp::fragDecoderErase, this));

        // Imposta la callback di invio pacchetti LoRa per LoRaFragmentedApp
        fragmentedApp->setSendLoRaPacketCallback(std::bind(&MyLoRaApp::sendLoRaPacket, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));

        // Registra i segnali per le statistiche
        decodingSuccessSignal = registerSignal("decodingSuccess");
        fragmentsReceivedSignal = registerSignal("fragmentsReceived");
        fragmentsLostSignal = registerSignal("fragmentsLost");
        packetsSentSignal = registerSignal("packetsSent");
        matrixErrorSignal = registerSignal("matrixError");
        overheadRatioSignal = registerSignal("overheadRatio");

        // Inizializza timer
        startAppTimer = new omnetpp::cMessage("startApp");
    }
    else if (stage == INITSTAGE_APPLICATION_LAYER) {
        // Invia il messaggio di avvio a tempo 0 per avviare l'applicazione
        scheduleAt(simTime(), startAppTimer);
    }
}

void MyLoRaApp::finish()
{
    // Annulla i timer pendenti
    cancelAndDelete(startAppTimer);

    EV << "MyLoRaApp finished.\n";
    fragmentedApp->finish(); // Chiama finish della tua app logica
}

void MyLoRaApp::handleMessage(omnetpp::cMessage *msg)
{
    if (msg == startAppTimer) {
        // Avvia la trasmissione dei dati
        EV << "MyLoRaApp: Starting data transmission at " << simTime() << "\n";
        startDataTransmission();
        delete msg; // Elimina il messaggio timer dopo l'uso
    }
    else {
        // Ricevuto un pacchetto dal livello LoRaWAN (dovrebbe essere un LoRaWANPacket)
        LoRaWANPacket* loRaPacket = dynamic_cast<LoRaWANPacket*>(msg);
        if (loRaPacket) {
            // Recupera il payload originale dal pacchetto LoRaWAN
            omnetpp::cBytes *payloadBytes = dynamic_cast<omnetpp::cBytes*>(loRaPacket->decapsulate()); // Decapsula il cBytes
            
            if (payloadBytes) {
                std::vector<uint8_t> packetData(payloadBytes->getData(), payloadBytes->getData() + payloadBytes->getLength());
                uint8_t port = loRaPacket->getFPort();
                uint8_t rssi = loRaPacket->getRssi(); // FLoRa dovrebbe fornire questi dati
                uint8_t snr = loRaPacket->getSnr();

                fragmentedApp->onLoRaPacketReceived(packetData, port, rssi, snr);

                // Emetti le statistiche del decoder dopo ogni elaborazione di frammento
                FragDecoderStatus status = fragmentedApp->getDecoderStatus();
                emit(fragmentsReceivedSignal, (double)status.FragNbRx);
                emit(fragmentsLostSignal, (double)status.FragNbLost);
                emit(matrixErrorSignal, (double)status.MatrixError); // Emetti 1.0 per errore, 0.0 altrimenti

                if (fragmentedApp->getRxSessionStatus() == FRAG_SESSION_FINISHED_OK) {
                    emit(decodingSuccessSignal, 1.0); // 1.0 per successo
                    // Calcola e emetti l'overhead ratio: pacchetti_reali_ricevuti / numOriginalFragments
                    double overheadRatio = (double)fragmentedApp->getPacketsPassedToDecoder() / numOriginalFragments;
                    emit(overheadRatioSignal, overheadRatio);
                    // Resetta lo stato della ricezione per una nuova sessione (se la simulazione ne prevede più di una)
                    fragmentedApp->resetRxSession();
                    fragmentedApp->getDecoder()->FragDecoderErase(); // Cancella anche la memoria del decoder
                } else if (fragmentedApp->getRxSessionStatus() == FRAG_SESSION_FINISHED_ERROR) {
                    emit(decodingSuccessSignal, 0.0); // 0.0 per fallimento
                    // In caso di fallimento, l'overhead ratio potrebbe essere alto o non applicabile.
                    // Potresti emettere un valore speciale (es. -1.0) o non emettere nulla per questo segnale.
                    fragmentedApp->resetRxSession();
                    fragmentedApp->getDecoder()->FragDecoderErase(); // Cancella anche la memoria del decoder
                }
                delete payloadBytes; // Elimina il cBytes decapsulato
            } else {
                EV_WARN << "Received LoRaWANPacket without cBytes payload. Ignoring.\n";
            }
        } else {
            EV_WARN << "Received unknown message type: " << msg->getName() << ". Ignoring.\n";
        }
        delete msg; // Elimina il messaggio LoRaWANPacket ricevuto
    }
}

void MyLoRaApp::refreshDisplay() const
{
    // Per aggiornamenti visuali in Qtenv
}

// Funzione callback per LoRaFragmentedApp per inviare pacchetti LoRa
void MyLoRaApp::sendLoRaPacket(const std::vector<uint8_t>& packetData, uint8_t port, uint8_t confirmType)
{
    // Crea un nuovo pacchetto LoRaWAN per FLoRa
    LoRaWANPacket *loRaPacket = new LoRaWANPacket("LoRaFragment");
    loRaPacket->setFPort(port); // Porta applicativa, 201 per la frammentazione standard
    loRaPacket->setTxPower(par("txPower").doubleValue()); // Recupera da omnetpp.ini se definito
    loRaPacket->setSF(par("sf").intValue());      // Recupera da omnetpp.ini
    loRaPacket->setBW(par("bw").doubleValue());    // Recupera da omnetpp.ini
    loRaPacket->setCR(par("cr").intValue());      // Recupera da omnetpp.ini
    loRaPacket->setMType(MType::UNCONFIRMED_DATA_UP); // Tipo di messaggio, per ora non confermato

    // Incapsula i dati raw del frammento
    omnetpp::cBytes *payloadBytes = new omnetpp::cBytes(reinterpret_cast<const char*>(packetData.data()), packetData.size());
    loRaPacket->encapsulate(payloadBytes);
    loRaPacket->setByteLength(payloadBytes->getLength()); // Imposta la lunghezza del pacchetto LoRaWAN

    // Invia il pacchetto attraverso il gate "socketOut"
    // Questo gate si connette a LoRaNic.upperLayerIn in LoRaNode.ned
    send(loRaPacket, "socketOut");
    emit(packetsSentSignal, 1.0); // Emetti un segnale ogni volta che un pacchetto viene inviato
}

// Implementazioni delle callback per la memoria del decoder
void MyLoRaApp::fragDecoderWrite(uint32_t addr, const void* buffer, uint32_t size)
{
    if (addr + size > decoderMemorySize) {
        throw omnetpp::cRuntimeError("FragDecoderWrite: Memory access out of bounds! Addr: %u, Size: %u, Memory Size: %u", addr, size, decoderMemorySize);
    }
    memcpy(decoderMemory.data() + addr, buffer, size);
}

void MyLoRaApp::fragDecoderRead(uint32_t addr, void* buffer, uint32_t size)
{
    if (addr + size > decoderMemorySize) {
        throw omnetpp::cRuntimeError("FragDecoderRead: Memory access out of bounds! Addr: %u, Size: %u, Memory Size: %u", addr, size, decoderMemorySize);
    }
    memcpy(buffer, decoderMemory.data() + addr, size);
}

void MyLoRaApp::fragDecoderErase()
{
    // In una simulazione, un semplice reset del buffer è sufficiente
    std::fill(decoderMemory.begin(), decoderMemory.end(), 0);
    EV << "FragDecoderMemory erased.\n";
}

void MyLoRaApp::startDataTransmission()
{
    std::vector<uint8_t> originalData = generateRandomData(dataSize);
    fragmentedApp->startTransmission(originalData);
}

std::vector<uint8_t> MyLoRaApp::generateRandomData(size_t size)
{
    std::vector<uint8_t> data(size);
    for (size_t i = 0; i < size; ++i) {
        data[i] = omnetpp::intrand(256); // Valori casuali da 0 a 255
    }
    return data;
}

} // namespace flora


//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
//

package flora.LoraNode;

import inet.mobility.static.StationaryMobility;
import inet.networklayer.common.InterfaceTable;
import inet.applications.contract.IApp;
import flora.LoRa.LoRaNic;
import flora.LoraNode.MyLoRaApp; // Importa MyLoRaApp

module LoRaNode
{
    parameters:
        int numApps = default(1);
        string deploymentType = default("");
        double maxGatewayDistance = default(320.0);
        double gatewayX = default(320.0);
        double gatewayY = default(320.0);

        string appType = default("flora.LoraNode.MyLoRaApp");

        @networkNode();
        *.interfaceTableModule = default(absPath(".interfaceTable"));
        @display("bgb=297,313;i=device/accesspoint;is=vs");
    submodules:
        interfaceTable: InterfaceTable {
            @display("p=30,26");
        }
        mobility: StationaryMobility {
            @display("p=24,88");
        }
        LoRaNic: LoRaNic {
            @display("p=137,239");
        }
        app[numApps]: <appType> like IApp {
            parameters:
                // Parametri per MyLoRaApp (e di conseguenza per LoRaFragmentedApp)
                numOriginalFragments = default(20);
                numRedundantFragments = default(10);
                fragmentSize = default(50);
                dataSize = default(900); // M * FragmentSize - Padding (controlla sia <= numOriginalFragments * fragmentSize)
                transmissionInterval = default(0s); // 0s per inviare tutti i frammenti subito

                // Parametri di trasmissione LoRa, se gestiti dall'app
                // Altrimenti, questi dovrebbero stare nel LoRaNic o essere letti da lì
                double txPower @unit(dBm) = default(14dBm);
                int sf = default(7); // Spreading Factor
                double bw @unit(kHz) = default(125kHz); // Bandwidth
                int cr = default(1); // Coding Rate

            @display("p=375,76,row,150");
        }
    connections allowunconnected:
        for i=0..numApps-1 {
            app[i].socketOut --> LoRaNic.upperLayerIn;
            LoRaNic.upperLayerOut --> app[i].socketIn;
        }
}
