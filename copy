#ifndef LORAFRAGMENTEDAPP_H
#define LORAFRAGMENTEDAPP_H

#include <omnetpp.h>
#include <string>
#include <vector>
#include <functional>
#include <numeric>
#include <algorithm>

#include "FragEncoder.h"
#include "FragDecoder.h"

#define FRAGMENTATION_DATA_FRAGMENT_CMD 0x08
#define FRAGMENTATION_PORT 201

#define START_TRANSMISSION_MSG_KIND 100

namespace fragmentedApp {
    std::vector<std::vector<uint8_t>> generateCodedFragments(
                const std::vector<uint8_t>& originalFileBuffer,
                uint16_t numFragments,
                uint8_t fragmentSize,
                uint16_t numCodedFragmentsToGenerate
            );

    void FragDecoderInit( uint16_t fragNb, uint8_t fragSize, FragDecoderCallbacks_t *callbacks );
    int32_t FragDecoderProcess( uint16_t fragCounter, uint8_t *rawData );
    FragDecoderStatus_t FragDecoderGetStatus( void );

    #define FRAG_SESSION_ONGOING            -1
    #define FRAG_SESSION_FINISHED_OK         0
    #define FRAG_SESSION_FINISHED_ERROR      1
}

enum FragSessionStatus {
    FRAG_SESSION_NOT_STARTED = -2,
    FRAG_SESSION_ONGOING_APP = -1,
    FRAG_SESSION_FINISHED_OK_APP = 0,
    FRAG_SESSION_FINISHED_ERROR_APP = 1
};

struct FragDecoderAppStatus {
    uint16_t FragNbRx;
    uint16_t FragNbLost;
    bool MatrixError;
};

struct FragSessionParameters {
    uint16_t fragNb;
    uint8_t fragSize;
    uint8_t m;
    uint8_t redundancy;
    uint8_t padding;
    uint8_t fragIndex;
    uint32_t dataSize;
};

class LoRaFragmentedApp : public omnetpp::cSimpleModule
{
  protected:
    FragSessionParameters sessionParams;

    std::vector<uint8_t> decoderMemoryBuffer;
    uint32_t decoderMemorySize;

    std::vector<uint8_t> rxFragmentBuffer;

    FragSessionStatus txSessionStatus;
    FragSessionStatus rxSessionStatus;

    uint32_t packetsSent;
    uint32_t packetsReceived;
    uint32_t packetsPassedToDecoder;
    uint32_t successfulDecodings;
    uint32_t failedDecodings;

    omnetpp::simsignal_t packetsSentSignal;
    omnetpp::simsignal_t fragmentsReceivedSignal;
    omnetpp::simsignal_t fragmentsLostSignal;
    omnetpp::simsignal_t matrixErrorSignal;
    omnetpp::simsignal_t decodingSuccessSignal;
    omnetpp::simsignal_t overheadRatioSignal;

    omnetpp::cGate* outGate;

    omnetpp::cMessage* startTxMsg;

    static void fragDecoderWrite(uint32_t addr, const void* buffer, uint32_t size);
    static void fragDecoderRead(uint32_t addr, void* buffer, uint32_t size);
    static void fragDecoderErase();

    virtual void initialize() override;
    virtual void handleMessage(omnetpp::cMessage* msg) override;
    virtual void finish() override;

    void startTransmission(const std::vector<uint8_t>& originalData);
    void sendLoRaPacket(const std::vector<uint8_t>& packetData, uint8_t port, uint8_t ackType); // Mantenuta per completezza, ma non usata
    void processLoRaPacket(omnetpp::cPacket* pkt);
    void resetRxSession();

  public:
    LoRaFragmentedApp();
    virtual ~LoRaFragmentedApp();

    FragDecoderAppStatus getDecoderStatus() const;
    FragSessionStatus getTxSessionStatus() const { return txSessionStatus; }
    FragSessionStatus getRxSessionStatus() const { return rxSessionStatus; }
    uint32_t getPacketsSent() const { return packetsSent; }
    uint32_t getPacketsReceived() const { return packetsReceived; }
    uint32_t getPacketsPassedToDecoder() const { return packetsPassedToDecoder; }
    uint32_t getSuccessfulDecodings() const { return successfulDecodings; }
    uint32_t getFailedDecodings() const { return failedDecodings; }
};

#endif // LORAFRAGMENTEDAPP_H







#include "LoRaFragmentedApp.h"
#include <iostream>
#include <numeric>
#include <algorithm>

#include "FragEncoder.h"
#include "FragDecoder.h"

using namespace fragmentedApp;

static std::vector<uint8_t>* globalDecoderMemoryBuffer = nullptr;
static uint32_t globalDecoderMemorySize = 0;

LoRaFragmentedApp::LoRaFragmentedApp() :
    txSessionStatus(FRAG_SESSION_NOT_STARTED),
    rxSessionStatus(FRAG_SESSION_NOT_STARTED),
    packetsSent(0),
    packetsReceived(0),
    packetsPassedToDecoder(0),
    successfulDecodings(0),
    failedDecodings(0),
    outGate(nullptr),
    startTxMsg(nullptr),
    decoderMemorySize(0)
{
}

LoRaFragmentedApp::~LoRaFragmentedApp()
{
    cancelAndDelete(startTxMsg);
    globalDecoderMemoryBuffer = nullptr;
    globalDecoderMemorySize = 0;
}

void LoRaFragmentedApp::fragDecoderWrite(uint32_t addr, const void* buffer, uint32_t size) {
    if (globalDecoderMemoryBuffer && addr + size <= globalDecoderMemorySize) {
        std::copy(static_cast<const uint8_t*>(buffer),
                  static_cast<const uint8_t*>(buffer) + size,
                  globalDecoderMemoryBuffer->begin() + addr);
    } else {
        EV_ERROR << "Decoder write error: out of bounds or buffer not set.\n";
    }
}

void LoRaFragmentedApp::fragDecoderRead(uint32_t addr, void* buffer, uint32_t size) {
    if (globalDecoderMemoryBuffer && addr + size <= globalDecoderMemorySize) {
        std::copy(globalDecoderMemoryBuffer->begin() + addr,
                  globalDecoderMemoryBuffer->begin() + addr + size,
                  static_cast<uint8_t*>(buffer));
    } else {
        EV_ERROR << "Decoder read error: out of bounds or buffer not set.\n";
    }
}

void LoRaFragmentedApp::fragDecoderErase() {
    if (globalDecoderMemoryBuffer) {
        std::fill(globalDecoderMemoryBuffer->begin(), globalDecoderMemoryBuffer->end(), 0);
    } else {
        EV_ERROR << "Decoder erase error: Buffer not set.\n";
    }
}

void LoRaFragmentedApp::initialize()
{
    packetsSentSignal = registerSignal("packetsSent");
    fragmentsReceivedSignal = registerSignal("fragmentsReceived");
    fragmentsLostSignal = registerSignal("fragmentsLost");
    matrixErrorSignal = registerSignal("matrixError");
    decodingSuccessSignal = registerSignal("decodingSuccess");
    overheadRatioSignal = registerSignal("overheadRatio");

    sessionParams.m = par("M");
    sessionParams.redundancy = par("R");
    sessionParams.fragSize = par("fragmentSize");
    sessionParams.dataSize = par("dataSize");
    sessionParams.fragIndex = par("sessionIndex");

    sessionParams.fragNb = sessionParams.m + sessionParams.redundancy;

    uint32_t originalDataBytesForEncoding = sessionParams.m * sessionParams.fragSize;
    if (sessionParams.dataSize > originalDataBytesForEncoding) {
        sessionParams.padding = 0; // Data will be truncated
    } else {
        sessionParams.padding = originalDataBytesForEncoding - sessionParams.dataSize;
    }

    decoderMemorySize = sessionParams.fragNb * sessionParams.fragSize;
    decoderMemoryBuffer.resize(decoderMemorySize);

    globalDecoderMemoryBuffer = &decoderMemoryBuffer;
    globalDecoderMemorySize = decoderMemorySize;

    FragDecoderCallbacks_t decoderCallbacks = {&LoRaFragmentedApp::fragDecoderWrite,
                                                &LoRaFragmentedApp::fragDecoderRead,
                                                &LoRaFragmentedApp::fragDecoderErase};
    fragmentedApp::FragDecoderInit(sessionParams.fragNb, sessionParams.fragSize, &decoderCallbacks);

    rxFragmentBuffer.resize(sessionParams.fragSize);

    outGate = gate("out");

    startTxMsg = new omnetpp::cMessage("startTxMsg", START_TRANSMISSION_MSG_KIND);
    scheduleAt(0.0, startTxMsg);
}

void LoRaFragmentedApp::handleMessage(omnetpp::cMessage* msg)
{
    if (msg == startTxMsg) {
        std::vector<uint8_t> originalData(sessionParams.dataSize);
        for (uint32_t i = 0; i < sessionParams.dataSize; ++i) {
            originalData[i] = (uint8_t)(i % 256); // Simple test data
        }
        startTransmission(originalData);
        delete msg;
        startTxMsg = nullptr;
    } else if (msg->isPacket()) {
        omnetpp::cPacket* pkt = omnetpp::check_and_cast<omnetpp::cPacket*>(msg);
        processLoRaPacket(pkt);
        delete pkt;
    } else {
        EV_WARN << "Received unknown message kind: " << msg->getKind() << "\n";
        delete msg;
    }
}

void LoRaFragmentedApp::finish() {
    emit(getAncestor()->registerSignal("finalPacketsSent"), (double)packetsSent);
    emit(getAncestor()->registerSignal("finalSuccessfulDecodings"), (double)successfulDecodings);
    emit(getAncestor()->registerSignal("finalFailedDecodings"), (double)failedDecodings);

    FragDecoderAppStatus finalStatus = getDecoderStatus();
    emit(getAncestor()->registerSignal("finalFragNbRx"), (double)finalStatus.FragNbRx);
    emit(getAncestor()->registerSignal("finalFragNbLost"), (double)finalStatus.FragNbLost);
    emit(getAncestor()->registerSignal("finalMatrixError"), (double)finalStatus.MatrixError);

    if (successfulDecodings > 0) {
        if (rxSessionStatus == FRAG_SESSION_FINISHED_OK_APP) {
             emit(overheadRatioSignal, (double)finalStatus.FragNbRx / sessionParams.m);
        } else {
             emit(overheadRatioSignal, 0.0);
        }
    } else {
        emit(overheadRatioSignal, 0.0);
    }
}

void LoRaFragmentedApp::startTransmission(const std::vector<uint8_t>& originalData)
{
    if (outGate == nullptr) {
        EV_ERROR << "Output gate not connected. Cannot start transmission.\n";
        txSessionStatus = FRAG_SESSION_FINISHED_ERROR_APP;
        return;
    }

    txSessionStatus = FRAG_SESSION_ONGOING_APP;
    packetsSent = 0;
    emit(packetsSentSignal, 0.0);

    std::vector<uint8_t> paddedOriginalData = originalData;
    size_t expectedEncoderInputSize = static_cast<size_t>(sessionParams.m) * sessionParams.fragSize;
    if (paddedOriginalData.size() < expectedEncoderInputSize) {
        paddedOriginalData.resize(expectedEncoderInputSize, 0);
    } else if (paddedOriginalData.size() > expectedEncoderInputSize) {
        paddedOriginalData.resize(expectedEncoderInputSize);
    }

    std::vector<std::vector<uint8_t>> allCodedFragments =
        fragmentedApp::generateCodedFragments(paddedOriginalData,
                                               sessionParams.m,
                                               sessionParams.fragSize,
                                               sessionParams.fragNb);

    if (allCodedFragments.empty() || allCodedFragments.size() != sessionParams.fragNb) {
        EV_ERROR << "Failed to generate coded fragments.\n";
        txSessionStatus = FRAG_SESSION_FINISHED_ERROR_APP;
        return;
    }

    for (uint16_t i = 0; i < sessionParams.fragNb; ++i) {
        uint16_t fragCounter = i;

        uint16_t headerValue = (static_cast<uint16_t>(sessionParams.fragIndex & 0x03) << 14) | (fragCounter & 0x3FFF);

        const std::vector<uint8_t>& currentFragment = allCodedFragments[i];

        omnetpp::cPacket* packet = new omnetpp::cPacket("fragPacket");

        std::vector<uint8_t> rawPayloadData(currentFragment.size() + 3);
        rawPayloadData[0] = FRAGMENTATION_DATA_FRAGMENT_CMD;
        rawPayloadData[1] = (headerValue >> 8) & 0xFF;
        rawPayloadData[2] = headerValue & 0xFF;
        std::copy(currentFragment.begin(), currentFragment.end(), rawPayloadData.begin() + 3);

        packet->setByteLength(rawPayloadData.size());
        packet->insert(new omnetpp::cBytes(rawPayloadData.data(), rawPayloadData.size()));

        send(packet, outGate);
        packetsSent++;
        emit(packetsSentSignal, (double)packetsSent);
    }
    txSessionStatus = FRAG_SESSION_FINISHED_OK_APP;
}

void LoRaFragmentedApp::sendLoRaPacket(const std::vector<uint8_t>& packetData, uint8_t port, uint8_t ackType) {
    // This method is now effectively unused since startTransmission sends directly.
    // Kept for backward compatibility if other parts of your code expect it.
}

void LoRaFragmentedApp::processLoRaPacket(omnetpp::cPacket* pkt)
{
    packetsReceived++;

    omnetpp::cBytes* bytesPayload = nullptr;
    if (pkt->has<omnetpp::cBytes>()) {
        bytesPayload = pkt->find<omnetpp::cBytes>();
    }

    if (bytesPayload == nullptr) {
        EV_ERROR << "Received packet with no payload. Ignoring.\n";
        return;
    }

    std::vector<uint8_t> packetData(bytesPayload->getData(), bytesPayload->getData() + bytesPayload->getDataLength());

    if (packetData.size() < 3) {
        EV << "Received too small packet. Ignoring.\n";
        return;
    }

    uint8_t command = packetData[0];
    if (command != FRAGMENTATION_DATA_FRAGMENT_CMD) {
        EV << "Received control command. Ignoring for now.\n";
        return;
    }

    uint16_t headerValue = (static_cast<uint16_t>(packetData[1]) << 8) | packetData[2];
    uint8_t receivedFragIndex = (headerValue >> 14) & 0x03;
    uint16_t receivedFragCounter = headerValue & 0x3FFF;

    if (receivedFragIndex != sessionParams.fragIndex) {
        EV << "Fragment for wrong session index. Ignoring.\n";
        return;
    }

    size_t payloadSize = packetData.size() - 3;
    if (payloadSize != sessionParams.fragSize) {
        EV << "Received fragment with wrong payload size. Ignoring.\n";
        return;
    }
    std::copy(packetData.begin() + 3, packetData.end(), rxFragmentBuffer.begin());

    packetsPassedToDecoder++;

    if (rxSessionStatus == FRAG_SESSION_NOT_STARTED) {
        rxSessionStatus = FRAG_SESSION_ONGOING_APP;
    }

    int32_t decodeStatus = fragmentedApp::FragDecoderProcess(receivedFragCounter, rxFragmentBuffer.data());

    emit(fragmentsReceivedSignal, (double)FragDecoderGetStatus().FragNbRx);
    emit(fragmentsLostSignal, (double)FragDecoderGetStatus().FragNbLost);

    if (decodeStatus == FRAG_SESSION_FINISHED_OK) {
        rxSessionStatus = FRAG_SESSION_FINISHED_OK_APP;
        successfulDecodings++;
        emit(decodingSuccessSignal, 1.0);

        emit(overheadRatioSignal, (double)FragDecoderGetStatus().FragNbRx / sessionParams.m);

        resetRxSession();
        FragDecoderCallbacks_t decoderCallbacks = {&LoRaFragmentedApp::fragDecoderWrite, &LoRaFragmentedApp::fragDecoderRead, &LoRaFragmentedApp::fragDecoderErase};
        fragmentedApp::FragDecoderInit(sessionParams.fragNb, sessionParams.fragSize, &decoderCallbacks);

    } else if (decodeStatus == FRAG_SESSION_FINISHED_ERROR) {
        rxSessionStatus = FRAG_SESSION_FINISHED_ERROR_APP;
        failedDecodings++;
        emit(decodingSuccessSignal, 0.0);
        emit(matrixErrorSignal, (double)FragDecoderGetStatus().MatrixError);

        resetRxSession();
        FragDecoderCallbacks_t decoderCallbacks = {&LoRaFragmentedApp::fragDecoderWrite, &LoRaFragmentedApp::fragDecoderRead, &LoRaFragmentedApp::fragDecoderErase};
        fragmentedApp::FragDecoderInit(sessionParams.fragNb, sessionParams.fragSize, &decoderCallbacks);
    }
}

FragDecoderAppStatus LoRaFragmentedApp::getDecoderStatus() const {
    fragmentedApp::FragDecoderStatus_t internalStatus = fragmentedApp::FragDecoderGetStatus();
    FragDecoderAppStatus appStatus;
    appStatus.FragNbRx = internalStatus.FragNbRx;
    appStatus.FragNbLost = internalStatus.FragNbLost;
    appStatus.MatrixError = (internalStatus.MatrixError == 1);
    return appStatus;
}

void LoRaFragmentedApp::resetRxSession() {
    rxSessionStatus = FRAG_SESSION_NOT_STARTED;
    packetsPassedToDecoder = 0;
}

Define_Module(LoRaFragmentedApp);




LORA.NED
// ... (omitted copyright and package declaration)

package flora.LoraNode;

import inet.mobility.static.StationaryMobility;
import inet.networklayer.common.InterfaceTable;
import flora.LoRa.LoRaNic;
import LoRaFragmentedApp; // Importa direttamente la tua classe, assumendo sia nello stesso progetto o in un path accessibile

module LoRaNode
{
    parameters:
        int numApps = default(1); // Per la tua configurazione, probabilmente vorrai che sia 1
        string deploymentType = default("");
        double maxGatewayDistance = default(320.0);
        double gatewayX = default(320.0);
        double gatewayY = default(320.0);
        // Rimosso appType: non serve più perché istanziamo direttamente LoRaFragmentedApp

        @networkNode();
        *.interfaceTableModule = default(absPath(".interfaceTable"));
        @display("bgb=297,313;i=device/accesspoint;is=vs");
    submodules:
        interfaceTable: InterfaceTable {
            @display("p=30,26");
        }
        mobility: StationaryMobility {
            @display("p=24,88");
        }
        LoRaNic: LoRaNic {
            @display("p=137,239");
        }
        // Qui istanziamo direttamente la tua app
        app: LoRaFragmentedApp { // Nessun array, dato che hai un'unica app ora
            parameters:
                @display("p=375,76,row,150");
        }
    connections allowunconnected:
        // Connessioni dirette per la tua app singola
        app.out --> LoRaNic.upperLayerIn; // Modificato da socketOut a out
        LoRaNic.upperLayerOut --> app.in; // Modificato da socketIn a in
}





OMNETT.INI
[General]
network = flora.simulations.LoRaNetworkTest
**.maxTransmissionDuration = 4s
**.energyDetection = -110dBm

#cmdenv-autoflush = true
#cmdenv-status-frequency = 10000000s
#cmdenv-express-mode = false
#cmdenv-output-file = cmd_env_log.txt
**.vector-recording = true

rng-class = "cMersenneTwister"
**.loRaGW[*].numUdpApps = 1
**.loRaGW[0].packetForwarder.localPort = 2000
**.loRaGW[0].packetForwarder.destPort = 1000
**.loRaGW[0].packetForwarder.destAddresses = "networkServer"
**.loRaGW[0].packetForwarder.indexNumber = 0

**.networkServer.numApps = 1
**.networkServer.**.evaluateADRinServer = true
**.networkServer.app[0].typename = "NetworkServerApp"
**.networkServer.app[0].destAddresses = "loRaGW[0]"
**.networkServer.app[0].destPort = 2000
**.networkServer.app[0].localPort = 1000
**.networkServer.app[0].adrMethod = ${"avg"}

# Rimosse le impostazioni specifiche di SimpleLoRaApp se non più rilevanti
# **.numberOfPacketsToSend = 0 # Non più direttamente gestito da LoRaFragmentedApp
# **.timeToFirstPacket = exponential(1000s) # LoRaFragmentedApp avvia la trasmissione in initialize
# **.timeToNextPacket = exponential(1000s) # LoRaFragmentedApp invia tutti i frammenti in una volta

sim-time-limit = 1d
simtime-resolution = -11
repeat = 30

**.alohaChannelModel = false

#nodes features
**.numberOfNodes = 1
**.constraintAreaMaxX = 1000m
**.constraintAreaMaxY = 1000m

**.loRaNodes[0].**.initialX = 300m
**.loRaNodes[0].**.initialY = 350m
**.loRaNodes[0].**initialLoRaSF = 12
**.loRaNodes[0].**initialLoRaTP = 14dBm
**.loRaNodes[0].**initialLoRaBW = 125 kHz
**.loRaNodes[0].**initialLoRaCR = 4
**.loRaNodes[0].**.initFromDisplayString = false
**.loRaNodes[0].**.evaluateADRinNode = true

# *** Modifica cruciale qui per la tua app ***
**.loRaNodes[*].numApps = 1 # Lascia 1, ma ora si riferisce all'unica istanza 'app'
**.loRaNodes[*].app.M = 3              # Numero di frammenti originali (M)
**.loRaNodes[*].app.R = 2              # Numero di frammenti di ridondanza (R)
**.loRaNodes[*].app.fragmentSize = 50  # Dimensione di ogni frammento in byte
**.loRaNodes[*].app.dataSize = 100     # Dimensione totale dei dati originali (es. 2 frammenti da 50 byte)
**.loRaNodes[*].app.sessionIndex = 0   # Indice della sessione (per ora 0)
# *** Fine modifica cruciale ***

#gateway features
**.numberOfGateways = 1
**.loRaGW[0].**.initialX = 200.00m
**.loRaGW[0].**.initialY = 200.00m
**.LoRaGWNic.radio.iAmGateway = true
**.loRaGW[*].**.initFromDisplayString = false

#power consumption features
**.loRaNodes[*].LoRaNic.radio.energyConsumer.typename = "LoRaEnergyConsumer"
**.loRaNodes[*].**.energySourceModule = "^.IdealEpEnergyStorage"
**.loRaNodes[*].LoRaNic.radio.energyConsumer.configFile = xmldoc("energyConsumptionParameters.xml")

#general features
**.sigma = 3.57
**.constraintAreaMinX = 0m
**.constraintAreaMinY = 0m
**.constraintAreaMinZ = 0m
**.constraintAreaMaxZ = 0m

LoRaNetworkTest.**.radio.separateTransmissionParts = false
LoRaNetworkTest.**.radio.separateReceptionParts = false

**.ipv4Delayer.config = xmldoc("cloudDelays.xml")
**.radio.radioMediumModule = "LoRaMedium"
**.LoRaMedium.pathLossType = "LoRaLogNormalShadowing"
**.minInterferenceTime = 0s
**.displayAddresses = false

# cache features
**.LoRaMedium.mediumLimitCacheType = "LoRaMediumCache"
**.LoRaMedium.rangeFilter = "communicationRange"
**.LoRaMedium.neighborCacheType = "LoRaNeighborCache"
**.LoRaMedium.neighborCache.range = 546m
**.LoRaMedium.neighborCache.refillPeriod = 3000s
